Socket and State
----------------

This is becoming very important because of the way the socket server must
interract with the pipeline.  It has implications on how the terminators are to
work at the very least.

* design player state
  - simple enough if it goes in the server
* communication between the pipeline (e.g output timestamps) and the server
* communication between the server and the pipeline (e.g load a file)
* socket protocol, i.e. actual client/server communication
* threading
  - can the server be seen as a plugin?

Pipeline Creation
-----------------

The current assert failure is at the input stage creation, but there are earlier
messups due to the connectors.  It might be difficult to organise the bits that
aren't connectors without doing the connectors first.

.connectors
* create_pipe
* start_terminator
* end_terminator
* pipe_junction
* assigning connectors to sections
* passing section pipes to sequences
  - currently they hold a pipe junction by value... there seems to be no option
    but to hold pointers to pipes

.create stage
* stage creator function in +stages+
* returns a simple_stage based on a stage_data

create_stage (in every sequence type)
* initialising a stage based on a built-in implementation
  - create_stage
  - the data needs to be better centralised (by using stage_data) so config can
    use it as well
  - perhaps a stage_data object can be initialised in the config object
  - prolly the stage data stuff should go in stages (that would make rather a
    lot more sense!)
* initialising a stage based on a loadable plugin
  - the stages module will have some "stage_data" object
  - it will be initialised in the config and loaded/partially loaded as needed
  - the create_stage methods will take this config
  - the stuff in the configs about stage data (the plug_id constants etc.) can
    be moved into stage module

.other bits
* storage of stages using indirect_owned<vector>.
  - it is common code so it should really be abstracted; copy what's in the
    progressive buffer
  - need to leave this until we know more about it because it depends how the
    allocation is done

Logging Output
--------------

This doesn't really become useful until track changing etc. is done.  So we need
the playlist state, socket server, and input handling done at the very least.

* use output in the config logging part
* add trace output calls all over the place

Pipeline Algorithms
-------------------

This is required for correct operation, but isn't testable anyway until we have
real output.

* fix the progressive buffer stack thing (section and progressive_buffer)
* check the section block check mess (but it's prolly pretty hard to organise
  without having working output)

Plugins
-------

* implement input and output stages
* properly deal with the design for loading built and shared object plugins

Problems
--------

* player state (e.g playlist including restoring state data)
  - this is the integration of socket and pipeline
* client communication (i.e saying when something has changed)
  - as above, but it's something that should be thought about in the socket
    proto anyway
  - issues with blocking: how do you mix communication over shared memory (i.e
    the thread pipe) and with a socket
* mono-threading the socket server (might be that the client communication and
  playlist stuff mean that it may as well sit in the same thread)
  - integration of socket and pipeline (perhaps it can be an observer plugin?)
  - this has implications for the player state because multi-threaded access
    will be more tricky
* loading plugin shared objects (probably will be covered in part by
  config-proto)
  - this is the integration of pipeline and config
* method of debugging the pipeline without being threaded (it's not even
  compiled yet so it's bound to have bugs!)
  - a helper program to load, run, and benchmark a plugin.  Perhaps a special
    mode of nerve?
* gradual initialisation of pipeline objects creates lots of messyness, but it's
  difficult to see exactly how we'd improve on it without doing massive amounts
  of allocation and indirect pointer storage
