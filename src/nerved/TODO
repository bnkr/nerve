Socket and State
----------------

This is becoming very important because of the way the socket server must
interract with the pipeline.  It has implications on how the terminators are to
work at the very least.

* design player state
  - simple enough if it goes in the server
* communication between the pipeline (e.g output timestamps) and the server
* communication between the server and the pipeline (e.g load a file)
* socket protocol, i.e. actual client/server communication
* threading
  - can the server be seen as a plugin?

Pipeline Creation
-----------------

The current assert failure is at the input stage creation, but there are earlier
messups due to the connectors.  It might be difficult to organise the bits that
aren't connectors without doing the connectors first.

.connectors
* create_pipe
* start_terminator
* end_terminator
* pipe_junction
* assigning connectors to sections
* passing section pipes to sequences
  - currently they hold a pipe junction by value... there seems to be no option
    but to hold pointers to pipes

.stages
* therea are more sequences' create_x methods to finish
* also the storage usage is not unified (they all need to use indirect.hpp)

Pipeline Algorithms
-------------------

This is required for correct operation, but isn't testable anyway until we have
real output.

* fix the progressive buffer stack thing (section and progressive_buffer)
* check the section block check mess (but it's prolly pretty hard to organise
  without having working output)

Plugins
-------

.Stage Data Tidy
* plan a way to get the stage type from a plugin for config
* modify stage_config's category stuff to use the plugin's data
* move stage_data object into config to implement this method
* modify stages::create_x to load a plugin properly

Problems
--------

* player state (e.g playlist including restoring state data)
  - this is the integration of socket and pipeline
* client communication (i.e saying when something has changed)
  - as above, but it's something that should be thought about in the socket
    proto anyway
  - issues with blocking: how do you mix communication over shared memory (i.e
    the thread pipe) and with a socket
* mono-threading the socket server (might be that the client communication and
  playlist stuff mean that it may as well sit in the same thread)
  - integration of socket and pipeline (perhaps it can be an observer plugin?)
  - this has implications for the player state because multi-threaded access
    will be more tricky
* method of debugging the pipeline without being threaded (it's not even
  compiled yet so it's bound to have bugs!)
  - a helper program to load, run, and benchmark a plugin.  Perhaps a special
    mode of nerve?
* gradual initialisation of pipeline objects creates lots of messyness, but it's
  difficult to see exactly how we'd improve on it without doing massive amounts
  of allocation and indirect pointer storage
* section buffering stuff etc.
  - it's still not totally clear whether the current section algorithm is right.
  - it avoids duplicate checks and input handling but incurrs the cost of the
    virtual connector implementation
  - the sequences can always guarantee zero or one packets returned
  - we need to know whether a sequence is buffering regardles of whether we use
    virtual connectors or not
  - therefore, the decision is virtual calls vs. several extra comparisons
    (return, buffering, output events, possily input events)
  - it's possible we could specialise sections when there are sequences which
    never buffer in either implementation
  - this is really a performance issue and needs to be properly benchmarked
