Socket and State
----------------

This is becoming very important because of the way the socket server must
interract with the pipeline.  It has implications on how the terminators are to
work at the very least.

* design player state
  - simple enough if it goes in the server
* communication between the pipeline (e.g output timestamps) and the server
* communication between the server and the pipeline (e.g load a file)
* socket protocol, i.e. actual client/server communication
* threading
  - can the server be seen as a plugin?

Pipeline Algorithms
-------------------

This is required for correct operation, but isn't testable anyway until we have
real output.

* fix the progressive buffer stack thing (section and progressive_buffer)
* check the section block check mess (but it's prolly pretty hard to organise
  without having working output)

Plugins
-------

.Stage Data Tidy
* plan a way to get the stage type from a plugin for config
* modify stage_config's category stuff to use the plugin's data
* move stage_data object into config to implement this method
* modify stages::create_x to load a plugin properly

Problems
--------

* method of debugging the pipeline without being threaded (it's not even
  compiled yet so it's bound to have bugs!)
  - a helper program to load, run, and benchmark a plugin.  Perhaps a special
    mode of nerve?
* gradual initialisation of pipeline objects creates lots of messyness, but it's
  difficult to see exactly how we'd improve on it without doing massive amounts
  of allocation and indirect pointer storage
* section buffering stuff etc.
  - it's still not totally clear whether the current section algorithm is right.
  - it avoids duplicate checks and input handling but incurrs the cost of the
    virtual connector implementation
  - the sequences can always guarantee zero or one packets returned
  - we need to know whether a sequence is buffering regardles of whether we use
    virtual connectors or not
  - therefore, the decision is virtual calls vs. several extra comparisons
    (return, buffering, output events, possily input events)
  - it's possible we could specialise sections when there are sequences which
    never buffer in either implementation
  - this is really a performance issue and needs to be properly benchmarked
