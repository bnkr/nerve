Socket and State
----------------

This is becoming very important because of the way the socket server must
interract with the pipeline.  It has implications on how the terminators are to
work at the very least.

* design player state
  - simple enough if it goes in the server
* communication between the pipeline (e.g output timestamps) and the server
* communication between the server and the pipeline (e.g load a file)
* socket protocol, i.e. actual client/server communication
* threading
  - can the server be seen as a plugin?

Pipeline Creation
-----------------

The current assert failure is at the input stage creation, but there are earlier
messups due to the connectors.  It might be difficult to organise the bits that
aren't connectors without doing the connectors first.

.connectors
* create_pipe
* start_terminator
* end_terminator
* pipe_junction
* assigning connectors to sections
* passing section pipes to sequences
  - currently they hold a pipe junction by value... there seems to be no option
    but to hold pointers to pipes

.stages
* stages::create bits
* sequences' create_x methods

.other bits
* storage and alloc of stages in stage sequence using indirect_owned<vector>.
  - it is common code so it should really be abstracted; copy what's in the
    progressive buffer
  - need to leave this until we know more about it because it depends how the
    allocation is done

Pipeline Algorithms
-------------------

This is required for correct operation, but isn't testable anyway until we have
real output.

* fix the progressive buffer stack thing (section and progressive_buffer)
* check the section block check mess (but it's prolly pretty hard to organise
  without having working output)

Plugins
-------

.Stage Data Tidy
* plan a way to get the stage type from a plugin for config
* modify stage_config's category stuff to use the plugin's data
* move stage_data object into config to implement this method
* modify stages::create_x to load a plugin properly

Problems
--------

* player state (e.g playlist including restoring state data)
  - this is the integration of socket and pipeline
* client communication (i.e saying when something has changed)
  - as above, but it's something that should be thought about in the socket
    proto anyway
  - issues with blocking: how do you mix communication over shared memory (i.e
    the thread pipe) and with a socket
* mono-threading the socket server (might be that the client communication and
  playlist stuff mean that it may as well sit in the same thread)
  - integration of socket and pipeline (perhaps it can be an observer plugin?)
  - this has implications for the player state because multi-threaded access
    will be more tricky
* loading plugin shared objects (probably will be covered in part by
  config-proto)
  - this is the integration of pipeline and config
* method of debugging the pipeline without being threaded (it's not even
  compiled yet so it's bound to have bugs!)
  - a helper program to load, run, and benchmark a plugin.  Perhaps a special
    mode of nerve?
* gradual initialisation of pipeline objects creates lots of messyness, but it's
  difficult to see exactly how we'd improve on it without doing massive amounts
  of allocation and indirect pointer storage
