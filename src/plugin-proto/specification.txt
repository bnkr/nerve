The Pipeline
------------

The player is an ordered list of 'stages' which form a 'pipeline'.

The 'pipeline' is also the order of inter-stage communication of 'packets'.
'packets' are the data which is being processed.  'Events' are types of 'packet'
on the 'pipeline'.

Input Stage
-----------

An 'input' is a kind of 'stage'.  The 'input' creates 'packets' from some kind
of I/O.  There is only ever one 'input' stage, and it must start the 'pipeline'.

The 'input' must handle several special 'events':

* +pause+ means stop reading
* +skip+ means move to a timestamp
* +load+ means load a new file
* +data+ means read more data

[*note:* This does not necessarily mean that the stage itself will query the
'packet' for event data.  It could be handled by the 'stage sequence' or the
'connections'.]

Simple Stage
------------

A 'simple stage' is a kind of 'stage' which takes 'packets' and then optionally
outputs packets.  A 'simple stage' can delay, drop, create, or modify 'packets'.

The 'simple stage' deals with the following 'events':

* +abandon+ means that the current work must be discarded because the context is
  changing (eg. song change).
* +flush+ means that no further work will appear (for now).  Any partially
  completed computation must be stopped and outputted (e.g playlist empty).
* +data+ is normal data to be processed.

The 'process' must propogate events to the next 'stage' in the 'stage sequence'
(i.e pass it down the 'pipeline').  [*note:* this would not necessarily be
done by a concrete stage object.]

Process Stage
-------------

A 'process' is a kind of 'simple stage'.  'Process stages' always come after the
'input'.

Output Stage
------------

An 'output' is a restriction of a 'simple stage'.  The 'output' writes its
'packets' to some sound hardware (or similar).  There is only ever one 'output'
stage it is always after the 'processes'.

The 'output' deals with the same 'events' as a 'process'.  Additionally, the
+configure+ event asks for the output to reconfigure itself for a new set of
parameters.

The 'output' including performs the same packet operations as a 'process'.
[*note:* This is necessary because an 'output' can be in the middle of a 'stage
sequence'.  If there is special handling for an 'output', then either each
'stage' will need to be checked by the 'stage sequence' or every 'stage' in the
sequence will need to check 'events' itself.  In other words, despite the
'output' doing what is essentially a noop, it actually works out being faster.
All that said, it does not necessarily mean that an actualy implementation of an
'output' needs the same concrete API as a 'process'; the "restriction" parts
(i.e no output modification) could be done in a shared place.]

[*note:* outputs often involve their own asynchronus queue (i.e the SDL thread)
which means the data would be shared with an observer.  This is OK because a)
observers don't modify and b), output data would need to be chunked anyway.]

The 'output' writes data to the 'input' to post 'events' which request more
data.  [*note:* this communication could involve a 'pipe' of 'local' or 'thread'
scope; therefore, it has the same constraints as a normal outputting of a
'packet', but it does not necessarily need to use an identical method.]

Observer Stage
--------------

An 'observer' is a kind of 'simple stage'.  It always comes after the 'output'
stage.  An 'observer' works like a 'process' and deals with the same 'events'.
An 'observer' always propogates its 'packets' [*note*: this would not
necessarily be done by a concrete implementation of an 'observer'; the predicate
is intended to specify that there is no option to drop a 'packet'].

Inter-Stage Communication
-------------------------

'Stages' communicate by 'pipes' which have the semantics of a queue.  A 'pipe'
can either be a 'local pipe' which is not thread-safe and can only communicate
within the 'stage sequence' or a 'thread pipe', which is thread safe and passes
'packets' on to a 'stage sequence' in another thread.

Stage Sequence
--------------

'Stages' are grouped into 'stage sequences'.  Each 'stage sequence' synchronises
several 'stages' in order of processing into one monothreaded group.

A 'stage sequence' iterates its list of 'stages' and calls the processing method
of the 'stage'.  The 'stage' itself will write its output to a 'pipe' [*note:*
the nature of this writing may be abstract as is could be more efficiant to
treat 'local pipes' and 'thread pipes' interchangably.]

'Stage sequences' are connected to each other in a 'connection'.  A 'connection'
works by using 'pipes'.  A 'connection' which reads data in is an 'input
connection' while one which writes data out is an 'output connection'.

The 'input connection' to first 'sequence' in the 'pipeline' and the output
'connection' after the final 'observer' are called 'terminators'; the 'initial
terminator' and 'final terminator' respectively.

The 'initial terminator' is responsible for reading the events used by an
'input' and converting the 'input's' data into 'passing stages'.

All 'output connections' except the 'final terminator' always use 'thread
pipes'.  All 'input connections' except the 'initial terminator' use 'thread
pipes'.  The 'initial terminator' can use a 'local pipe' if the 'input' and
'output' 'stages' are both in the same 'job'. [*note:* This means that if the
'input' and 'output' are in the same thread, only one of them blocks (the
'output') but otherwise they both block due to normal 'pipe' smenatics.]

Jobs
----

'Stage sequences' are contained in 'jobs'.  Each 'job' represents a single
thread.  A 'job' can contain multiple 'stage sequences'. [*note:* Thus, a job
can block multiple times.

Problems
--------

.extra input buffer operations
- in a stage sequence which is not the start terminator, we only read a single
  packet
- the current API design requires that add this single packet to a buffer before
  processing.

.observers
* the current stage sequence is massively over the top for observers which never
  actually modify anything or output multiple packets
* we could add an +observer_stage_sequence+
* an additional advantage of same would be that we might possibly fix the API
  difficulties with the output stage (it could perhaps be solved in the same way
  as input stages).
* in order to preserve "any stage in any thread", this means relaxing the
  requirements on non-terminating stage sequences outputting to thread pipes.
* this causes difficulties regarding blocking again, but I think only if the
  entire sequence is in one thread... and even then we have to block on
  something from the socket server or the SDL output thread at some point.
