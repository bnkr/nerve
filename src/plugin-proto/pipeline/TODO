* communication with the progressive buffer.
  - I put a pipe junction in there which has different meanings in the spec and
    data pipe code.
  - the intended meaning by the spec is that the junction has connectors in it
  - since we know a sequence only returns zero or one packet then it's not a
    huge deal to just return a literal packet.
* name of packet_return
* header file for packet_return (packets.hpp or stages.hpp or its own?)
* section blocking check:
  - I'm pretty sure it matters whether we block on input and output, but at the
    moment we only check input... I think this is an algorithmic detal, because
    it's the section class which decides blocking.
* progressive buffering:
  - we store an iterator to the last stage/seqeuence to buffer
  - suppose a stage/seq notifies that it's buffering
  - and then another one does
  - buffering finishes, we overwrote the other buffering object so another input
    packet gets written
  - best option is a stack of buffering iterators
  - said stack only needs to equal the length of the sequences/stages
* connectors:
  - at least the first version of the pipeline will use connectors.  None of
    that is properly implemented just yet.
