// Copyright (C) 2009-2011, James Webber.
// Distributed under a 3-clause BSD license.  See COPYING.

// Warnings:
//
// - if you put an empty block "{}" as the rule action, lemon will generate a
//   rule which falls through to the next one above it in the stack!!!  This
//   means that actions can be called more than once in obscure circumstances.
//   This is a totally insane bug.
// - the code blocks don't have syntax analysis at all so if you have a
//   token(VAR) and a "VAR" in a string somewhere, then the VAR will be silently
//   overwritten wherever it occurs!!!

%token_prefix T_

%include {
// We can't use quote includes for compiler reasons so we need an -I.  Then the
// inc file can use quote paths and dependencies are all correct.
#include <grammar_header.inc.hpp>

#define TRACE(code__)\
  std::printf("%d: %s\n", __LINE__, #code__);\
  code__;
}

// Only works as a pointer.
%extra_argument { ::config::lemon_interface::context_type *context }

// What the lexer will give the parser for the third parameter of the Parse
// function.
%token_type { config::flex_interface::token_type }

// In theory this will already be handled by the "error" rules.
%parse_failure { context->reporter().report_fatal("unhandled syntax error"); }

%syntax_error {
  // TODO:
  //   This isn't working properly because this routine doesn't get called until
  //   there has been 3 tokens successfully shifted.  Unfortunately the "empty
  //   code blcok" fuckup might have been obscuring some stuff here.
  // std::cout << "syntax error routine" << std::endl;

  set_last_error(yymajor, TOKEN);
  // just in case I forget elsewere
  context->reporter().report();
  use_variable(yymajor);
  use_variable(yyminor);
}

%stack_overflow {
  use_variable(yypMinor);
  // Nicer to avoid aborting.  We might be able to do some cleaner exiting.
  context->reporter().report_fatal("config parser out of stack");
}

// Dummy to stop unused var warnings.
%destructor config { use_variable(yypminor); use_variable(context); }

// Start synbol.
config_file ::= config_seq . { }
config_file ::= . { ERR("empty configuration"); }

config_seq ::= config . { }
config_seq ::= config_seq config . { }

config ::= thread .

/***********
 * Threads *
 ***********/

thread ::= thread_key LBRACE thread_conf_seq RBRACE . { context->end_job(); }
thread ::= thread_key empty_block . { context->end_job(); }

// TODO:
//   It'd be useful to have the thread key kick the lexer into a special state
//   which only lexes the keys we want so, for example, the 'AFTER' token will
//   appear as an identifier instead.  This could make the parser a little more
//   simple because we don't need to repeat all the tokens we want to have
//   errors for.  The actual code won't be different because duplicate rules end
//   up in the same switch case.

thread_key ::= THREAD . { TRACE(context->new_job()); }
thread_key ::= error . { TRACE(context->new_job()); ERR_EXPECTED("'thread' before '{'"); }

thread_conf_seq ::= thread_conf . { }
thread_conf_seq ::= thread_conf_seq thread_conf . { }

thread_conf ::= section . { }
thread_conf ::= invalid_field .

/************
 * Sections *
 ************/

section ::= section_key LBRACE section_conf_seq RBRACE . {
  config::section_config &s = context->this_section();
  std::cout << s.name() << std::endl;
  if (s.name() == NULL) { ERR("section has no 'name' field"); }
  if (s.after_name() == NULL) { ERR("section has no 'after' field"); }
  context->end_section();
}
section ::= section_key empty_block . { context->end_section(); }
section ::= section_key error . { context->end_section(); ERR_EXPECTED("'{' after section-key"); }

section_key ::= SECTION . { TRACE(context->new_section()); }
section_key ::= error . { TRACE(context->new_section()); ERR_EXPECTED("'section' before '{'"); }

section_conf_seq ::= section_conf .
section_conf_seq ::= section_conf_seq section_conf .

section_conf ::= stage .
section_conf ::= NAME EQ conf_string(S) . { context->this_section().name(make_pass_text(S)); }
section_conf ::= AFTER EQ conf_string(S) . { context->this_section().after_name(make_pass_text(S)); }
section_conf ::= invalid_field .

/**********
 * Stages *
 **********/

stage ::= stage_key LBRACE stage_conf_seq RBRACE . { context->end_stage(); }
stage ::= stage_key empty_block . { context->end_stage(); }

stage_key ::= STAGE . { TRACE(context->new_stage()); }
stage_key ::= INPUT . { TRACE(context->new_stage()); }
stage_key ::= OUTPUT . { TRACE(context->new_stage()); }
stage_key ::= error . { ERR_EXPECTED("'stage', 'input', or 'output' before '{'"); }

stage_conf_seq ::= stage_conf . { }
stage_conf_seq ::= stage_conf_seq stage_conf . { }

stage_conf ::= PATH EQ conf_string(S) . { context->this_stage().path(make_pass_text(S)); }
stage_conf ::= TYPE EQ conf_string(S) . {
  config::flex_interface::text_ptr p = make_pass_text(S);
  typedef config::stage_config::stage_ids id_type;
  id_type id = text_to_id(p.get());
  if (id == stage_config::id_unset) {
    ERR("not a valid stage type: %s", p.get());
  }
  else {
    context->this_stage().type(id);
  }
}
stage_conf ::= non_stage_conf .

non_stage_conf ::= PATH error . { ERR_EXPECTED("'=' after 'path'"); }
non_stage_conf ::= TYPE error . { ERR_EXPECTED("'=' after 'type'"); }
non_stage_conf ::= error EQ any_value . { ERR_EXPECTED("'path', 'type', 'name', or 'after' before '='"); }

any_value ::= error . { ERR_EXPECTED("value after '='"); }
any_value ::= string .

/**********
 * Errors *
 **********/

invalid_field ::= error EQ error . { ERR("field is not valid here"); }

/********
 * Util *
 ********/

%type conf_string { char * }
conf_string ::= error . { ERR_EXPECTED("string after '='"); }
conf_string(RET) ::= string(S) . { RET = S; }

%type string { char * }
string(RET) ::= STRING_LIT(S) . { RET = S.text; }
string(RET) ::= IDENTIFIER_LIT(S) . { RET = S.text; }

empty_block ::= LBRACE RBRACE . { ERR("empty config"); }
