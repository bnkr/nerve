// Copyright (C) 2009-2011, James Webber.
// Distributed under a 3-clause BSD license.  See COPYING.

%token_prefix T_

%include {
// We can't use quote includes for compiler reasons so we need an -I.  Then the
// inc file can use quote paths and dependencies are all correct.
#include <grammar_header.inc.hpp>
}

// Only works as a pointer.
%extra_argument { ::config::lemon_interface::context_type *context }

// What the lexer will give the parser for the third parameter of the Parse
// function.
%token_type { config::flex_interface::token_data }

%parse_failure { context->reporter().report_fatal(); }

// In theory this will already be handled by the "error" rules.
%syntax_error {
  set_last_error(yymajor, TOKEN);
  context->reporter().report();
  use_variable(yymajor);
  use_variable(yyminor);
}

%stack_overflow {
  use_variable(yypMinor);
  NERVE_ABORT("kersplooosh!");
}

%destructor config {
  use_variable(yypminor); use_variable(context);
}

// Start synbol.
config ::= thread_seq . {
}

/***********
 * Threads *
 ***********/

thread_seq ::= thread . { }
thread_seq ::= thread_seq thread . {}

thread ::= THREAD LBRACE thread_conf_seq RBRACE . {}

thread_conf_seq ::= thread_conf . {}
thread_conf_seq ::= thread_conf_seq thread_conf . {}

thread_conf ::= section . {}
thread_conf ::= stage . {}

/************
 * Sections *
 ************/

section ::= SECTION LBRACE section_conf_seq RBRACE . {}

section_conf_seq ::= stage . {}
section_conf_seq ::= section_conf_seq stage . {}

/**********
 * Stages *
 **********/

stage ::= STAGE LBRACE stage_conf_seq RBRACE . {}
stage ::= INPUT LBRACE stage_conf_seq RBRACE . {}
stage ::= OUTPUT LBRACE stage_conf_seq RBRACE . {}

stage_conf_seq ::= stage_conf . {}
stage_conf_seq ::= stage_conf_seq stage_conf . {}

stage_conf ::= PATH EQ normal_value . {}
stage_conf ::= TYPE EQ normal_value . {}
stage_conf ::= NAME EQ normal_value . {}
stage_conf ::= AFTER EQ after_value . {}
stage_conf ::= error EQ any_value . {
  ERR_EXPECTED("'path', 'type', 'name', or 'after' before '='");
}

any_value ::= error . {}
any_value ::= string .
any_value ::= INPUT .
any_value ::= OUTPUT .

after_value ::= error . {
  ERR_EXPECTED("string, 'input', or 'output' after '='");
}
after_value ::= string .
after_value ::= INPUT .
after_value ::= OUTPUT .

normal_value ::= error . {
  ERR_EXPECTED("string after '='");
}
normal_value ::= string .

/********
 * Util *
 ********/

string ::= STRING_LIT .
string ::= IDENTIFIER_LIT .
