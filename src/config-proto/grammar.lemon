// Copyright (C) 2009-2011, James Webber.
// Distributed under a 3-clause BSD license.  See COPYING.

// Warnings:
//
// - if you put an empty block "{}" as the rule action, lemon will generate a
//   rule which falls through to the next one above it in the stack!!!  This
//   means that actions can be called more than once in obscure circumstances.
//   This is a totally insane bug.
// - the code blocks don't have syntax analysis at all so if you have a
//   token(VAR) and a "VAR" in a string somewhere, then the VAR will be silently
//   overwritten wherever it occurs!!!

%token_prefix T_

%include {
// We can't use quote includes for compiler reasons so we need an -I.  Then the
// inc file can use quote paths and dependencies are all correct.
#include <grammar_header.inc.hpp>

#define TRACE(code__)\
  std::printf("%d: %s\n", __LINE__, #code__);\
  code__;
}

// Only works as a pointer.
%extra_argument { ::config::lemon_interface::context_type *context }

// What the lexer will give the parser for the third parameter of the Parse
// function.
%token_type { config::flex_interface::token_type }

// In theory this will already be handled by the "error" rules.
%parse_failure { context->reporter().report_fatal("unhandled syntax error"); }

%syntax_error {
  // TODO:
  //   This isn't working properly because this routine doesn't get called until
  //   there has been 3 tokens successfully shifted.  Unfortunately the "empty
  //   code blcok" fuckup might have been obscuring some stuff here.
  // std::cout << "syntax error routine" << std::endl;

  set_last_error(yymajor, TOKEN);
  // just in case I forget elsewere
  context->reporter().report();
  use_variable(yymajor);
  use_variable(yyminor);
}

%stack_overflow {
  use_variable(yypMinor);
  // Nicer to avoid aborting.  We might be able to do some cleaner exiting.
  context->reporter().report_fatal("config parser out of stack");
}

// Dummy to stop unused var warnings.
%destructor config { use_variable(yypminor); use_variable(context); }

// Start synbol.
config_file ::= config_seq . { }
config_file ::= . { ERR("empty configuration"); }

config_seq ::= config . { }
config_seq ::= config_seq config . { }

config ::= thread .

/***********
 * Threads *
 ***********/

thread ::= thread_key LBRACE thread_conf_seq RBRACE . { context->end_job(); }
thread ::= thread_key empty_block . { context->end_job(); }

// TODO:
//   It'd be useful to have the thread key kick the lexer into a special state
//   which only lexes the keys we want so, for example, the 'AFTER' token will
//   appear as an identifier instead.  This could make the parser a little more
//   simple because we don't need to repeat all the tokens we want to have
//   errors for.  The actual code won't be different because duplicate rules end
//   up in the same switch case.

thread_key ::= THREAD . { context->new_job(); }
thread_key ::= error . { context->new_job(); ERR_EXPECTED("'thread' before '{'"); }

thread_conf_seq ::= thread_conf . { }
thread_conf_seq ::= thread_conf_seq thread_conf . { }

thread_conf ::= section . { }

/************
 * Sections *
 ************/

section ::= section_key LBRACE section_conf_seq RBRACE . {
  config::section_config &s = context->this_section();
  // Note: we don't check after_name because it input state won't have one.
  if (s.name() == NULL) { ERR("section has no 'name' field"); }
  context->end_section();
}
section ::= section_key empty_block . { context->end_section(); }
section ::= section_key error . { context->end_section(); ERR_EXPECTED("'{' after section-key"); }

section_key ::= SECTION . { context->new_section(); }
section_key ::= error . { context->new_section(); ERR_EXPECTED("'section' before '{'"); }

section_conf_seq ::= section_conf .
section_conf_seq ::= section_conf_seq section_conf .

section_conf ::= NAME string(S) . {
  if (context->this_section().name() != NULL) {
    ERR("'name' field already set");
  }
  else{
    context->this_section().name(make_text_ptr(S));
  }
}
section_conf ::= AFTER string(S) . {
  if (context->this_section().after_name() != NULL) {
    ERR("'after' field already set");
  }
  else {
    context->this_section().after_name(make_text_ptr(S), context->reporter().location());
  }
}
section_conf ::= STAGE string(S) . { context->add_stage(make_text_ptr(S)); }

section_conf ::= error string(S) . {
  ERR_EXPECTED("'name', 'after', or 'stage'");
  config::flex_interface::free_text(S);
}
section_conf ::= NAME error . { ERR_EXPECTED("string value for field") }
section_conf ::= AFTER error . { ERR_EXPECTED("string value for field") }
section_conf ::= STAGE error . { ERR_EXPECTED("string value for field") }

/********
 * Util *
 ********/

%type string { char * }
%destructor string { config::flex_interface::free_text($$); }
string(RET) ::= STRING_LIT(S) . { RET = S.text; }
string(RET) ::= IDENTIFIER_LIT(S) . { RET = S.text; }

empty_block ::= LBRACE RBRACE . { ERR("empty config"); }
