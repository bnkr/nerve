#ifndef FFMPEG_AUDIO_STREAM_HPP_gpn6q9w3
#define FFMPEG_AUDIO_STREAM_HPP_gpn6q9w3

namespace ffmpeg {

//! \brief Interface to the audio stream and codec data.
class audio_stream {
  public:
    //! \brief Gets the n'th audio stream.  Throws stream_error or unsupported_codec_error.
    //TODO:
    //  it would be nicer if we can inspect all the streams and choose the best one.
    //  Perhaps I should pass a chooser function?
    audio_stream(file &f, std::size_t stream_num = 0) {
      AVFormatContext &fmt_ctx = f.format_context();
      for (std::size_t i = 0; i < f.num_streams(); ++i) {
        if (fmt_ctx.streams[i]->codec->codec_type == CODEC_TYPE_AUDIO) {
          if (stream_num != 0) {
            --stream_num;
          }
          else {
            stream_ = fmt_ctx.streams[i];
            assert(stream_ != NULL);
            assert(stream_->codec != NULL);
            goto ok;
          }
        }
      }

      throw stream_error("no audio stream found");
ok:
      codec_ = avcodec_find_decoder(codec_context().codec_id);
      if (! codec_) {
        // TODO: say what the codec is.
        throw unsupported_codec_error("");
      }

      /*
      // TODO: don't know what this implies (or if it's relevant to audio).
      // Inform the codec that we can handle truncated bitstreams -- i.e.,
      // bitstreams where frame boundaries can fall in the middle of packets
      if (codec_->capabilities & CODEC_CAP_TRUNCATED) {
        codec_context().flags |= CODEC_FLAG_TRUNCATED;
      }
      */

      if (avcodec_open(&codec_context(), codec_) < 0) {
        // TODO: expanded info
        throw codec_open_error("could not initialise codec");
      }

      /*
      // TODO: not sure if I need this - just for videos?
      // Hack to correct wrong frame rates that seem to be generated by some
      // codecs
      if (codec_context().frame_rate > 1000 && codec_context().frame_rate_base == 1) {
        codec_context().frame_rate_base = 1000;
      }
      */
    }

    ~audio_stream() { avcodec_close(&codec_context()); }

    //! \name ffmpeg structure accessors.
    //@{

    //! \brief Contains codec data amongst other things.
    //! See:
    //! - http://www.dranger.com/ffmpeg/data.html#AVStream
    //! - http://www.irisa.fr/texmex/people/dufouil/ffmpegdoxy/structAVStream.html
    AVStream &stream() { return *stream_; }
    const AVStream &stream() const { return *stream_; }

    //! \brief Direct accessor to the codec informational data.  Enormous struct.
    //! Use \link codec_context \endlink unless giving this to an ffmpeg function.
    AVCodecContext &codec_context() { return *stream_->codec; }
    const AVCodecContext &codec_context() const { return *stream_->codec; }

    //! \brief Mostly to with the actual en/de-coding process.
    AVCodec &codec() { return *codec_; }
    const AVCodec &codec() const { return *codec_; }
    //@}


    //! \name AVStream and AVCodec (not codec_context) accessors.
    //@{

    //! \brief All timestamps of *this stream* (ie, frames) are encoded in this way.
    //! Use timestamp * av_q2d(time_base()) on packet timestamps etc.  This is not
    //! the same as the codec time base, or AV_TIME_BASE which is used for the file
    //! context.
    const AVRational &time_base() const { return stream().time_base; }

    //! \brief time_base() as a double.
    const double time_base_double() const { return av_q2d(stream().time_base); }

    //@}


  private:
    AVStream *stream_;
    AVCodec *codec_;
};


//! \brief Friendly interface for the AVCodecContext struct.
//! See:
//! - http://www.dranger.com/ffmpeg/data.html#AVCodecContext
//! - http://www.irisa.fr/texmex/people/dufouil/ffmpegdoxy/structAVCodecContext.html
class codec_context {
  public:
    codec_context(audio_stream &str) : st_(str) { }

    int sample_rate() const { return ctx().sample_rate; }
    int channels() const { return ctx().channels; }
    int average_bit_rate() { return ctx().bit_rate; }
    //! \brief Fractional seconds which all times are represented in.
    //! For fixed-fps content, timebase should be 1/framerate and timestamp increments
    //! should be identically 1.
    //!
    //! Note: this does not appear to be the same as audio_stream::time_base().
    //TODO: what is this for if it is zero all the time?
    const AVRational &time_base() const { return ctx().time_base; }
    double time_base_double() const { return av_q2d(time_base()); }
    //! \brief Which frame did we just decode?
    int frame_number() const { return ctx().frame_number; }

  private:
    audio_stream &st_;

    AVCodecContext &ctx() { return st_.codec_context(); }
    const AVCodecContext &ctx() const { return st_.codec_context(); }
};

}

#endif
